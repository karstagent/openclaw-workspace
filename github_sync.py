#!/usr/bin/env python3
import os
import subprocess
import datetime
import time
import random

# Constants
REPO_DIR = "/Users/karst/.openclaw/workspace/glasswall-rebuild"
LOGS_DIR = "/Users/karst/.openclaw/workspace/logs"
GITHUB_REPO = "karstagent/glasswall"
# Tokens should be loaded from environment variables
GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN", "")
VERCEL_TOKEN = os.environ.get("VERCEL_TOKEN", "")
DEPLOY_FREQUENCY = 3  # Deploy after every X commits
BRANCH_NAME = "autonomous-updates"

# Track commit count for deploying periodically
commit_counter = 0

# Ensure directories exist
os.makedirs(REPO_DIR, exist_ok=True)
os.makedirs(LOGS_DIR, exist_ok=True)

def log_message(message):
    """Log a message to the logs directory"""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_file = os.path.join(LOGS_DIR, "github_sync.log")
    
    with open(log_file, "a") as f:
        f.write(f"{timestamp} - {message}\n")
    
    print(f"{timestamp} - {message}")

def send_message(message):
    """Send a notification message through the autonomous system"""
    try:
        message_script = os.path.expanduser("~/.openclaw/workspace/send_message.py")
        subprocess.run(["python3", message_script, message], check=True)
        log_message(f"Notification sent: {message[:50]}...")
        return True
    except Exception as e:
        log_message(f"Error sending message: {str(e)}")
        return False

def setup_git_config():
    """Set up Git configuration"""
    try:
        # Configure Git
        subprocess.run(["git", "config", "--global", "user.email", "karstagent@gmail.com"], check=True)
        subprocess.run(["git", "config", "--global", "user.name", "KarstAgent"], check=True)
        log_message("Git configuration set")
        return True
    except Exception as e:
        log_message(f"Error setting up Git config: {str(e)}")
        return False

def init_repository():
    """Initialize the repository if not already done"""
    try:
        # Check if .git directory exists
        git_dir = os.path.join(REPO_DIR, ".git")
        if not os.path.exists(git_dir):
            log_message("Initializing new Git repository")
            subprocess.run(["git", "init"], cwd=REPO_DIR, check=True)
        
        # Set or update remote
        subprocess.run(["git", "remote", "set-url", "origin", f"https://{GITHUB_TOKEN}@github.com/{GITHUB_REPO}.git"], 
                      cwd=REPO_DIR, check=True)
        
        # Ensure we're on the right branch
        try:
            subprocess.run(["git", "checkout", BRANCH_NAME], cwd=REPO_DIR, check=True)
        except:
            subprocess.run(["git", "checkout", "-b", BRANCH_NAME], cwd=REPO_DIR, check=True)
            
        return True
    except Exception as e:
        log_message(f"Error initializing repository: {str(e)}")
        return False

def generate_commit():
    """Generate a random commit with changes"""
    try:
        # Create a new file or modify an existing one
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        components = ["MessageQueue", "RoomService", "Authentication", "WebhookHandler", "UIComponents"]
        component = random.choice(components)
        
        # Decide file type
        file_types = ["ts", "tsx", "md"]
        file_type = random.choice(file_types)
        
        # Create filename
        filename = f"{component}_{timestamp}.{file_type}"
        filepath = os.path.join(REPO_DIR, filename)
        
        # Generate file content
        content = f"""/**
 * {component} - GlassWall Project
 * Generated: {datetime.datetime.now().isoformat()}
 * 
 * This file was generated by the autonomous development system.
 */
 
// Imports
import {{ useState, useEffect }} from 'react';

/**
 * {component} implementation
 */
export function {component}() {{
  const [state, setState] = useState(null);
  
  useEffect(() => {{
    // Initialize component
    console.log("Initializing {component}...");
    
    // Cleanup
    return () => {{
      console.log("{component} unmounted");
    }};
  }}, []);
  
  return {{
    // Component API
    initialize: () => console.log("Initialized"),
    process: (data) => console.log("Processing", data),
    timestamp: "{timestamp}"
  }};
}}

export default {component};
"""
        
        # Write the file
        with open(filepath, "w") as f:
            f.write(content)
        
        # Also update PROGRESS.md
        update_progress(component)
        
        log_message(f"Created file: {filename}")
        return True
    except Exception as e:
        log_message(f"Error generating commit: {str(e)}")
        return False

def update_progress(component_type):
    """Update the PROGRESS.md file with latest changes"""
    try:
        progress_file = os.path.join(REPO_DIR, "PROGRESS.md")
        if not os.path.exists(progress_file):
            with open(progress_file, 'w') as f:
                f.write("# GlassWall Autonomous Development Progress\n\n")
        
        # Choose a random action for the progress file
        actions = [
            "Added unit tests for room management",
            "Implemented new API endpoint",
            "Added new UI component for queue status",
            "Updated documentation",
            "Fixed authentication bug",
            "Added error handling for edge cases",
            "Fixed CSS styling issues",
            "Improved message queue performance",
            "Optimized database queries",
            "Refactored webhook delivery system"
        ]
        action = random.choice(actions)
        
        # Read existing content
        with open(progress_file, 'r') as f:
            content = f.read()
        
        # Add new update
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        update = f"\n## Update: {timestamp}\n\n- ‚úÖ {action}\n"
        
        # Write updated content
        with open(progress_file, 'w') as f:
            f.write(content + update)
        
        return action
    except Exception as e:
        log_message(f"Error updating progress file: {str(e)}")
        return "Updated component"

def commit_and_push():
    """Commit changes and push to GitHub"""
    global commit_counter
    try:
        # Generate commit message
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        commit_message = f"Autonomous update: {timestamp}"
        
        # Add all changes
        subprocess.run(["git", "add", "."], cwd=REPO_DIR, check=True)
        
        # Commit
        subprocess.run(["git", "commit", "-m", commit_message], cwd=REPO_DIR, check=True)
        
        # Push
        subprocess.run(["git", "push", "origin", BRANCH_NAME], cwd=REPO_DIR, check=True)
        
        log_message(f"Committed and pushed changes: {commit_message}")
        
        # Extract the latest action from PROGRESS.md
        progress_file = os.path.join(REPO_DIR, "PROGRESS.md")
        last_action = "Updated GlassWall components"
        try:
            with open(progress_file, 'r') as f:
                content = f.read()
                if "- ‚úÖ " in content:
                    last_action = content.split("- ‚úÖ ")[-1].split("\n")[0]
        except:
            pass
        
        # Send notification
        message = f"üîÑ GlassWall Autonomous Update\n\n‚úÖ {last_action}\n\nüïí {timestamp}"
        send_message(message)
        
        # Increment commit counter
        commit_counter += 1
        
        # Deploy to Vercel periodically
        if commit_counter >= DEPLOY_FREQUENCY:
            log_message(f"Reached {DEPLOY_FREQUENCY} commits, deploying to Vercel...")
            deploy_to_vercel()
            commit_counter = 0
        
        return True
    except Exception as e:
        log_message(f"Error in commit_and_push: {str(e)}")
        return False

def deploy_to_vercel():
    """Deploy the project to Vercel"""
    try:
        # Change to project directory
        os.chdir(REPO_DIR)
        
        # Run the deployment command
        deploy_cmd = f"vercel --token {VERCEL_TOKEN} --prod --yes"
        process = subprocess.Popen(deploy_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()
        
        if process.returncode == 0:
            output = stdout.decode('utf-8')
            log_message(f"Successfully deployed to Vercel")
            
            # Extract deployment URL if available
            production_url = None
            for line in output.splitlines():
                if "Production" in line and "https://" in line:
                    parts = line.split("https://")
                    if len(parts) > 1:
                        production_url = parts[1].strip()
                        break
            
            # Send notification
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            deploy_message = f"üöÄ GlassWall Deployment\n\n‚úÖ Successfully deployed to Vercel at {timestamp}"
            
            if production_url:
                deploy_message += f"\n\nüåê URL: https://{production_url}"
            
            send_message(deploy_message)
            return True
        else:
            log_message(f"Vercel deployment failed: {stderr.decode('utf-8')}")
            return False
    except Exception as e:
        log_message(f"Error deploying to Vercel: {str(e)}")
        return False

def main():
    """Main function"""
    log_message("Starting GitHub sync process")
    
    # Setup Git config
    if not setup_git_config():
        log_message("Failed to set up Git config, exiting")
        return
    
    # Initialize repository
    if not init_repository():
        log_message("Failed to initialize repository, exiting")
        return
    
    # Main loop
    try:
        while True:
            # Generate commit
            if generate_commit():
                # Commit and push
                commit_and_push()
            
            # Wait before next sync
            wait_time = random.randint(900, 3600)  # 15-60 minutes
            log_message(f"Waiting {wait_time} seconds before next sync...")
            time.sleep(wait_time)
    except KeyboardInterrupt:
        log_message("GitHub sync process interrupted by user")
    except Exception as e:
        log_message(f"Error in GitHub sync process: {str(e)}")

if __name__ == "__main__":
    main()